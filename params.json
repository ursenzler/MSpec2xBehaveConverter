{"name":"MSpec 2 xBehave Converter","tagline":"Helps to migrate from Machine.Specifications to xBehave","body":"# Machine.Specifications to xBehave.net converter\r\nHelps to migrate specifications or tests made with MSpec to xBehave.net by doing all the syntax replacement for you.\r\n\r\n# What the converter does (maybe looking at the samples below is easier to understand :-O )\r\nThe converter tries to convert the MSpec syntax to xBehave.net syntax:\r\n* for every class attributed by `Subject` it creates an enclosing class (the class holding the Scenario) and a method for the Scenario.\r\n* for every `Establish`, `Because` and `It` it creates a corresponding string with `_(() =>` notation containing the corresponding action.\r\n* it copies the name of the class in MSpec syntax to the _because_ string in xBehave syntax\r\n* it removes the `_` from all names.\r\n* it replaces the Machine.Specifications using with XBehave\r\n* it tries to let everything else as is.\r\n\r\n# Preparatory steps\r\n1. Add a reference (Nuget) to xBehave.net >= 2.0 (currently in pre-release).\r\n1. Inline all `Subject(CONSTANT)` so that it looks like `Subject(\"some text\")`.\r\n1. Make sure that everything is under version control in case the converter _obfuscates_ your code.\r\n\r\n# Scenarios\r\nSee samples on how to migrate specifications.\r\n\r\n## Happy case\r\n\r\nMSpec:\r\n```c# \r\nnamespace Appccelerate.EvaluationEngine\r\n{\r\n    using FluentAssertions;\r\n    using Machine.Specifications;\r\n\r\n    [Subject(\"Question answering\")]\r\n    public class When_calling_answer_with_expressions_with_constraints\r\n    {\r\n        private const string NoConstraint = \"N\";\r\n        private const string WithTrueConstraint = \"T\";\r\n        private const string WithFalseConstraint = \"F\";\r\n\r\n        private static IEvaluationEngine engine;\r\n\r\n        private static string answer;\r\n\r\n        Establish context = () =>\r\n            {\r\n                engine = new EvaluationEngine();\r\n\r\n                engine.Solve<WhatIsTheText, string>()\r\n                    .AggregateWithExpressionAggregator(string.Empty, (aggregate, value) => aggregate + value)\r\n                    .ByEvaluating((q, p) => NoConstraint)\r\n                    .When(q => false)\r\n                        .ByEvaluating((q, p) => WithFalseConstraint)\r\n                    .When(q => true)\r\n                        .ByEvaluating((q, p) => WithTrueConstraint);\r\n            };\r\n\r\n        Because of = () =>\r\n            {\r\n                answer = engine.Answer(new WhatIsTheText());\r\n            };\r\n\r\n        It should_evaluate_expressions_without_constraints = () => \r\n            answer.Should().Contain(NoConstraint);\r\n\r\n        It should_evaluate_expressions_with_fulfilled_constraints = () => \r\n            answer.Should().Contain(WithTrueConstraint);\r\n\r\n        It should_ignore_expressions_with_constraints_that_are_not_fulfilled = () => \r\n            answer.Should().NotContain(WithFalseConstraint);\r\n    }\r\n}\r\n```\r\n\r\nAfter automatic conversion:\r\n```c#\r\nnamespace Appccelerate.EvaluationEngine\r\n{\r\n    using FluentAssertions;\r\n    using Xbehave;\r\n\r\n    public partial class Question_answering\r\n    {\r\n        [Scenario]\r\n        public void When_calling_answer_with_expressions_with_constraints()\r\n        {\r\n        private const string NoConstraint = \"N\";\r\n        private const string WithTrueConstraint = \"T\";\r\n        private const string WithFalseConstraint = \"F\";\r\n\r\n            IEvaluationEngine engine = null;\r\n\r\n            string answer = null;\r\n\r\n            \"establish\"._(() =>\r\n            {\r\n                engine = new EvaluationEngine();\r\n\r\n                engine.Solve<WhatIsTheText, string>()\r\n                    .AggregateWithExpressionAggregator(string.Empty, (aggregate, value) => aggregate + value)\r\n                    .ByEvaluating((q, p) => NoConstraint)\r\n                    .When(q => false)\r\n                        .ByEvaluating((q, p) => WithFalseConstraint)\r\n                    .When(q => true)\r\n                        .ByEvaluating((q, p) => WithTrueConstraint);\r\n            });\r\n\r\n            \"when calling answer with expressions with constraints\"._(() =>\r\n            {\r\n                answer = engine.Answer(new WhatIsTheText());\r\n            });\r\n\r\n            \"it should evaluate expressions without constraints\"._(() =>\r\n            {\r\n                answer.Should().Contain(NoConstraint);\r\n            });\r\n\r\n            \"it should evaluate expressions with fulfilled constraints\"._(() =>\r\n            {\r\n                answer.Should().Contain(WithTrueConstraint);\r\n            });\r\n\r\n            \"it should ignore expressions with constraints that are not fulfilled\"._(() =>\r\n            {\r\n                answer.Should().NotContain(WithFalseConstraint);\r\n            });\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nRemove `private` from constant definitions:\r\n```c#\r\nnamespace Appccelerate.EvaluationEngine\r\n{\r\n    using FluentAssertions;\r\n    using Xbehave;\r\n\r\n    public partial class Question_answering\r\n    {\r\n        [Scenario]\r\n        public void When_calling_answer_with_expressions_with_constraints()\r\n        {\r\n            const string NoConstraint = \"N\";\r\n            const string WithTrueConstraint = \"T\";\r\n            const string WithFalseConstraint = \"F\";\r\n\r\n            IEvaluationEngine engine = null;\r\n\r\n            string answer = null;\r\n\r\n            \"establish\"._(() =>\r\n            {\r\n                engine = new EvaluationEngine();\r\n\r\n                engine.Solve<WhatIsTheText, string>()\r\n                    .AggregateWithExpressionAggregator(string.Empty, (aggregate, value) => aggregate + value)\r\n                    .ByEvaluating((q, p) => NoConstraint)\r\n                    .When(q => false)\r\n                        .ByEvaluating((q, p) => WithFalseConstraint)\r\n                    .When(q => true)\r\n                        .ByEvaluating((q, p) => WithTrueConstraint);\r\n            });\r\n\r\n            \"when calling answer with expressions with constraints\"._(() =>\r\n            {\r\n                answer = engine.Answer(new WhatIsTheText());\r\n            });\r\n\r\n            \"it should evaluate expressions without constraints\"._(() =>\r\n            {\r\n                answer.Should().Contain(NoConstraint);\r\n            });\r\n\r\n            \"it should evaluate expressions with fulfilled constraints\"._(() =>\r\n            {\r\n                answer.Should().Contain(WithTrueConstraint);\r\n            });\r\n\r\n            \"it should ignore expressions with constraints that are not fulfilled\"._(() =>\r\n            {\r\n                answer.Should().NotContain(WithFalseConstraint);\r\n            });\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis spec is runnable.\r\n\r\nNow let's finish with some clean-up:\r\n* move locals to method parameters (Ctrl+R, Ctrl+P in R#)\r\n* remove partial (not needed in this scenario)\r\n* better naming instead of `establish`\r\n* shorten the scenario name\r\n```c#\r\nnamespace Appccelerate.EvaluationEngine\r\n{\r\n    using FluentAssertions;\r\n    using Xbehave;\r\n\r\n    public class Question_answering\r\n    {\r\n        [Scenario]\r\n        public void Constraints(\r\n            IEvaluationEngine engine, \r\n            string answer)\r\n        {\r\n            const string NoConstraint = \"N\";\r\n            const string WithTrueConstraint = \"T\";\r\n            const string WithFalseConstraint = \"F\";\r\n\r\n            \"establish an evaluation engine with constraint expressions\"._(() =>\r\n            {\r\n                engine = new EvaluationEngine();\r\n\r\n                engine.Solve<WhatIsTheText, string>()\r\n                    .AggregateWithExpressionAggregator(string.Empty, (aggregate, value) => aggregate + value)\r\n                    .ByEvaluating((q, p) => NoConstraint)\r\n                    .When(q => false)\r\n                        .ByEvaluating((q, p) => WithFalseConstraint)\r\n                    .When(q => true)\r\n                        .ByEvaluating((q, p) => WithTrueConstraint);\r\n            });\r\n\r\n            \"when calling answer with expressions with constraints\"._(() =>\r\n            {\r\n                answer = engine.Answer(new WhatIsTheText());\r\n            });\r\n\r\n            \"it should evaluate expressions without constraints\"._(() =>\r\n            {\r\n                answer.Should().Contain(NoConstraint);\r\n            });\r\n\r\n            \"it should evaluate expressions with fulfilled constraints\"._(() =>\r\n            {\r\n                answer.Should().Contain(WithTrueConstraint);\r\n            });\r\n\r\n            \"it should ignore expressions with constraints that are not fulfilled\"._(() =>\r\n            {\r\n                answer.Should().NotContain(WithFalseConstraint);\r\n            });\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFinished!\r\n\r\n## Converting Specs with base classes\r\nIf you used base classes in your MSpec specifications, then you need to prepare your classes first.\r\n\r\nThere are several possibilities:\r\n* inline all code in the base class in the derived classes (probably introducing a lot of code duplication)\r\n* move the code from the base class into a helper class that you call from within the establish of the derived classes (no code duplication)\r\n* convert the derived classes and the base class and move the code from the base class as a `Background` step into the merged class holding all scenarios. (see below)\r\n\r\n```c#\r\nnamespace Appccelerate.EvaluationEngine\r\n{\r\n    using System;\r\n\r\n    using FluentAssertions;\r\n\r\n    using Machine.Specifications;\r\n\r\n    [Subject(Concern.HierarchicalEngines)]\r\n    public class When_calling_answer_on_a_child_evaluation_engine : HierarchicalEngineContext\r\n    {\r\n        private static string childAnswer;\r\n\r\n        Because of = () =>\r\n            {\r\n                childAnswer = ChildEngine.Answer(new Question());\r\n            };\r\n\r\n        It should_override_parent_aggregator_with_child_aggregator = () => \r\n            childAnswer.Should().Contain(ChildAggregator);\r\n\r\n        It should_use_expressions_from_child_and_parent = () => \r\n            childAnswer\r\n                .Should().Contain(ParentExpression)\r\n                .And.Contain(ChildExpression);\r\n\r\n        It should_evaluate_expressions_from_parent_first = () =>\r\n            childAnswer.EndsWith(ParentExpression + ChildExpression, StringComparison.Ordinal)\r\n                .Should().BeTrue();\r\n    }\r\n\r\n    [Subject(Concern.HierarchicalEngines)]\r\n    public class When_calling_answer_on_a_parent_evaluation_engine : HierarchicalEngineContext\r\n    {\r\n        private static string parentAnswer;\r\n\r\n        Because of = () =>\r\n            {\r\n                parentAnswer = ParentEngine.Answer(new Question());\r\n            };\r\n\r\n        It should_use_parent_aggregator = () => \r\n            parentAnswer.Should().Contain(ParentAggregator);\r\n\r\n        It should_use_expressions_only_from_parent = () => \r\n            parentAnswer.Should().NotContain(ChildExpression);\r\n    }\r\n\r\n    [Subject(Concern.HierarchicalEngines)]\r\n    public class HierarchicalEngineContext\r\n    {\r\n        protected const string ParentAggregator = \"parentAggregator\";\r\n        protected const string ChildAggregator = \"childAggregator\";\r\n        protected const string ParentExpression = \"parentExpression\";\r\n        protected const string ChildExpression = \"childExpression\";\r\n        \r\n        Establish context = () =>\r\n        {\r\n            ParentEngine = new EvaluationEngine();\r\n            ChildEngine = new EvaluationEngine(ParentEngine);\r\n\r\n            ParentEngine.Solve<Question, string>()\r\n            .AggregateWithExpressionAggregator(ParentAggregator, (aggregate, value) => aggregate + value)\r\n            .ByEvaluating((q, p) => ParentExpression);\r\n\r\n            ChildEngine.Solve<Question, string>()\r\n                .AggregateWithExpressionAggregator(ChildAggregator, (aggregate, value) => aggregate + value)\r\n                .ByEvaluating((q, p) => ChildExpression);\r\n        };\r\n\r\n        protected static IEvaluationEngine ParentEngine { get; private set; }\r\n\r\n        protected static IEvaluationEngine ChildEngine { get; private set; }\r\n\r\n        protected class Question : IQuestion<string>\r\n        {\r\n            public string Describe()\r\n            {\r\n                return \"test question\";\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAfter automatic conversion:\r\n```c#\r\nnamespace Appccelerate.EvaluationEngine\r\n{\r\n    using System;\r\n\r\n    using FluentAssertions;\r\n\r\n    using Xbehave;\r\n\r\n    public partial class Hierarchical_evaluation_engines\r\n    {\r\n        [Scenario]\r\n        public void When_calling_answer_on_a_child_evaluation_engine()\r\n        {\r\n            string childAnswer = null;\r\n\r\n            \"when calling answer on a child evaluation engine\"._(() =>\r\n            {\r\n                childAnswer = ChildEngine.Answer(new Question());\r\n            });\r\n\r\n            \"it should override parent aggregator with child aggregator\"._(() =>\r\n            {\r\n                childAnswer.Should().Contain(ChildAggregator);\r\n            });\r\n\r\n            \"it should use expressions from child and parent\"._(() =>\r\n            {\r\n                childAnswer\r\n                .Should().Contain(ParentExpression)\r\n                .And.Contain(ChildExpression);\r\n            });\r\n\r\n            \"it should evaluate expressions from parent first\"._(() =>\r\n            {\r\n                childAnswer.EndsWith(ParentExpression + ChildExpression, StringComparison.Ordinal)\r\n                .Should().BeTrue();\r\n            });\r\n    }\r\n\r\n    public partial class Hierarchical_evaluation_engines\r\n    {\r\n        [Scenario]\r\n        public void When_calling_answer_on_a_parent_evaluation_engine()\r\n        {\r\n            string parentAnswer = null;\r\n\r\n            \"when calling answer on a child evaluation engine\"._(() =>\r\n            {\r\n                parentAnswer = ParentEngine.Answer(new Question());\r\n            });\r\n\r\n            \"it should use parent aggregator\"._(() =>\r\n            {\r\n                parentAnswer.Should().Contain(ParentAggregator);\r\n            });\r\n\r\n            \"it should use expressions only from parent\"._(() =>\r\n            {\r\n                parentAnswer.Should().NotContain(ChildExpression);\r\n            });\r\n    }\r\n\r\n    public partial class Hierarchical_evaluation_engines\r\n    {\r\n        [Scenario]\r\n        public void HierarchicalEngineContext()\r\n        {\r\n        protected const string ParentAggregator = \"parentAggregator\";\r\n        protected const string ChildAggregator = \"childAggregator\";\r\n        protected const string ParentExpression = \"parentExpression\";\r\n        protected const string ChildExpression = \"childExpression\";\r\n        \r\n            \"establish\"._(() =>\r\n            {\r\n            ParentEngine = new EvaluationEngine();\r\n            ChildEngine = new EvaluationEngine(ParentEngine);\r\n\r\n            ParentEngine.Solve<Question, string>()\r\n            .AggregateWithExpressionAggregator(ParentAggregator, (aggregate, value) => aggregate + value)\r\n            .ByEvaluating((q, p) => ParentExpression);\r\n\r\n            ChildEngine.Solve<Question, string>()\r\n                .AggregateWithExpressionAggregator(ChildAggregator, (aggregate, value) => aggregate + value)\r\n                .ByEvaluating((q, p) => ChildExpression);\r\n        });\r\n        }\r\n        }\r\n        }\r\n\r\n        protected static IEvaluationEngine ParentEngine { get; private set; }\r\n\r\n        protected static IEvaluationEngine ChildEngine { get; private set; }\r\n\r\n        protected class Question : IQuestion<string>\r\n        {\r\n            public string Describe()\r\n            {\r\n                return \"test question\";\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nMake it runnable:\r\n* remove the second partial class definition `public partial class Hierarchical_evaluation_engines {` so that you just have a single class with Scenarios.\r\n* move the fields and nested classes into the class holding the Scenarios\r\n* move the `establish` from the base class into the class holding the Scenarios as a `Background` step\r\n\r\n```c#\r\nnamespace Appccelerate.EvaluationEngine\r\n{\r\n    using System;\r\n\r\n    using FluentAssertions;\r\n\r\n    using Xbehave;\r\n\r\n    public partial class Hierarchical_evaluation_engines\r\n    {\r\n        protected const string ParentAggregator = \"parentAggregator\";\r\n        protected const string ChildAggregator = \"childAggregator\";\r\n        protected const string ParentExpression = \"parentExpression\";\r\n        protected const string ChildExpression = \"childExpression\";\r\n        \r\n        [Background]\r\n        public void Background()\r\n        {\r\n            \"establish\"._(() =>\r\n            {\r\n            ParentEngine = new EvaluationEngine();\r\n            ChildEngine = new EvaluationEngine(ParentEngine);\r\n\r\n            ParentEngine.Solve<Question, string>()\r\n            .AggregateWithExpressionAggregator(ParentAggregator, (aggregate, value) => aggregate + value)\r\n            .ByEvaluating((q, p) => ParentExpression);\r\n\r\n            ChildEngine.Solve<Question, string>()\r\n                .AggregateWithExpressionAggregator(ChildAggregator, (aggregate, value) => aggregate + value)\r\n                .ByEvaluating((q, p) => ChildExpression);\r\n            });\r\n        }\r\n\r\n        protected static IEvaluationEngine ParentEngine { get; private set; }\r\n\r\n        protected static IEvaluationEngine ChildEngine { get; private set; }\r\n\r\n        protected class Question : IQuestion<string>\r\n        {\r\n            public string Describe()\r\n            {\r\n                return \"test question\";\r\n            }\r\n        }\r\n\r\n        [Scenario]\r\n        public void When_calling_answer_on_a_child_evaluation_engine()\r\n        {\r\n            string childAnswer = null;\r\n\r\n            \"when calling answer on a child evaluation engine\"._(() =>\r\n            {\r\n                childAnswer = ChildEngine.Answer(new Question());\r\n            });\r\n\r\n            \"it should override parent aggregator with child aggregator\"._(() =>\r\n            {\r\n                childAnswer.Should().Contain(ChildAggregator);\r\n            });\r\n\r\n            \"it should use expressions from child and parent\"._(() =>\r\n            {\r\n                childAnswer\r\n                .Should().Contain(ParentExpression)\r\n                .And.Contain(ChildExpression);\r\n            });\r\n\r\n            \"it should evaluate expressions from parent first\"._(() =>\r\n            {\r\n                childAnswer.EndsWith(ParentExpression + ChildExpression, StringComparison.Ordinal)\r\n                .Should().BeTrue();\r\n            });\r\n    }\r\n\r\n        [Scenario]\r\n        public void When_calling_answer_on_a_parent_evaluation_engine()\r\n        {\r\n            string parentAnswer = null;\r\n\r\n            \"when calling answer on a child evaluation engine\"._(() =>\r\n            {\r\n                parentAnswer = ParentEngine.Answer(new Question());\r\n            });\r\n\r\n            \"it should use parent aggregator\"._(() =>\r\n            {\r\n                parentAnswer.Should().Contain(ParentAggregator);\r\n            });\r\n\r\n            \"it should use expressions only from parent\"._(() =>\r\n            {\r\n                parentAnswer.Should().NotContain(ChildExpression);\r\n            });\r\n\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAnd then some clean-up:\r\n* remove partial\r\n* remove unnecessary `protected`\r\n* better naming of establish in Background step, of class holding scenarios and method names of scenarios\r\n* move fields and nested class to a nicer place inside class holding Scenarios\r\n* remove unnecessary white space\r\n\r\n```c#\r\nnamespace Appccelerate.EvaluationEngine\r\n{\r\n    using System;\r\n\r\n    using FluentAssertions;\r\n\r\n    using Xbehave;\r\n\r\n    public class HierarchicalEvaluationEngines\r\n    {\r\n        const string ParentAggregator = \"parentAggregator\";\r\n        const string ChildAggregator = \"childAggregator\";\r\n        const string ParentExpression = \"parentExpression\";\r\n        const string ChildExpression = \"childExpression\";\r\n\r\n        private static IEvaluationEngine ParentEngine { get; set; }\r\n        private static IEvaluationEngine ChildEngine { get; set; }\r\n\r\n        [Background]\r\n        public void Background()\r\n        {\r\n            \"establish a hierarchical evaluation engine\"._(() =>\r\n            {\r\n                ParentEngine = new EvaluationEngine();\r\n                ChildEngine = new EvaluationEngine(ParentEngine);\r\n\r\n                ParentEngine.Solve<Question, string>()\r\n                .AggregateWithExpressionAggregator(ParentAggregator, (aggregate, value) => aggregate + value)\r\n                .ByEvaluating((q, p) => ParentExpression);\r\n\r\n                ChildEngine.Solve<Question, string>()\r\n                    .AggregateWithExpressionAggregator(ChildAggregator, (aggregate, value) => aggregate + value)\r\n                    .ByEvaluating((q, p) => ChildExpression);\r\n            });\r\n        }\r\n\r\n        [Scenario]\r\n        public void QuestionChild(string childAnswer)\r\n        {\r\n            \"when calling answer on a child evaluation engine\"._(() =>\r\n            {\r\n                childAnswer = ChildEngine.Answer(new Question());\r\n            });\r\n\r\n            \"it should override parent aggregator with child aggregator\"._(() =>\r\n            {\r\n                childAnswer.Should().Contain(ChildAggregator);\r\n            });\r\n\r\n            \"it should use expressions from child and parent\"._(() =>\r\n            {\r\n                childAnswer\r\n                .Should().Contain(ParentExpression)\r\n                .And.Contain(ChildExpression);\r\n            });\r\n\r\n            \"it should evaluate expressions from parent first\"._(() =>\r\n            {\r\n                childAnswer.EndsWith(ParentExpression + ChildExpression, StringComparison.Ordinal)\r\n                .Should().BeTrue();\r\n            });\r\n        }\r\n\r\n        [Scenario]\r\n        public void QuestionParent(string parentAnswer)\r\n        {\r\n            \"when calling answer on a child evaluation engine\"._(() =>\r\n            {\r\n                parentAnswer = ParentEngine.Answer(new Question());\r\n            });\r\n\r\n            \"it should use parent aggregator\"._(() =>\r\n            {\r\n                parentAnswer.Should().Contain(ParentAggregator);\r\n            });\r\n\r\n            \"it should use expressions only from parent\"._(() =>\r\n            {\r\n                parentAnswer.Should().NotContain(ChildExpression);\r\n            });\r\n        }\r\n\r\n        private class Question : IQuestion<string>\r\n        {\r\n            public string Describe()\r\n            {\r\n                return \"test question\";\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nBe happy!","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}