<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Mspec2xbehaveconverter by ursenzler</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Mspec2xbehaveconverter</h1>
      <h2 class="project-tagline">Helps to migrate from Machine.Specifications to xBehave</h2>
      <a href="https://github.com/ursenzler/MSpec2xBehaveConverter" class="btn">View on GitHub</a>
      <a href="https://github.com/ursenzler/MSpec2xBehaveConverter/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/ursenzler/MSpec2xBehaveConverter/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="machinespecifications-to-xbehavenet-converter" class="anchor" href="#machinespecifications-to-xbehavenet-converter" aria-hidden="true"><span class="octicon octicon-link"></span></a>Machine.Specifications to xBehave.net converter</h1>

<p>Helps to migrate specifications or tests made with MSpec to xBehave.net by doing all the syntax replacement for you.</p>

<h1>
<a id="what-the-converter-does-maybe-looking-at-the-samples-below-is-easier-to-understand--o-" class="anchor" href="#what-the-converter-does-maybe-looking-at-the-samples-below-is-easier-to-understand--o-" aria-hidden="true"><span class="octicon octicon-link"></span></a>What the converter does (maybe looking at the samples below is easier to understand :-O )</h1>

<p>The converter tries to convert the MSpec syntax to xBehave.net syntax:</p>

<ul>
<li>for every class attributed by <code>Subject</code> it creates an enclosing class (the class holding the Scenario) and a method for the Scenario.</li>
<li>for every <code>Establish</code>, <code>Because</code> and <code>It</code> it creates a corresponding string with <code>_(() =&gt;</code> notation containing the corresponding action.</li>
<li>it copies the name of the class in MSpec syntax to the <em>because</em> string in xBehave syntax</li>
<li>it removes the <code>_</code> from all names.</li>
<li>it replaces the Machine.Specifications using with XBehave</li>
<li>it tries to let everything else as is.</li>
</ul>

<h1>
<a id="preparatory-steps" class="anchor" href="#preparatory-steps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Preparatory steps</h1>

<ol>
<li>Add a reference (Nuget) to xBehave.net &gt;= 2.0 (currently in pre-release).</li>
<li>Inline all <code>Subject(CONSTANT)</code> so that it looks like <code>Subject("some text")</code>.</li>
<li>Make sure that everything is under version control in case the converter <em>obfuscates</em> your code.</li>
</ol>

<h1>
<a id="scenarios" class="anchor" href="#scenarios" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scenarios</h1>

<p>See samples on how to migrate specifications.</p>

<h2>
<a id="happy-case" class="anchor" href="#happy-case" aria-hidden="true"><span class="octicon octicon-link"></span></a>Happy case</h2>

<p>MSpec:</p>

<div class="highlight highlight-c#"><pre><span class="pl-k">namespace</span> <span class="pl-en">Appccelerate.EvaluationEngine</span>
{
    <span class="pl-k">using</span> FluentAssertions;
    <span class="pl-k">using</span> Machine.Specifications;

    [Subject(<span class="pl-s"><span class="pl-pds">"</span>Question answering<span class="pl-pds">"</span></span>)]
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">When_calling_answer_with_expressions_with_constraints</span>
    {
        <span class="pl-k">private</span> <span class="pl-k">const</span> <span class="pl-k">string</span> NoConstraint = <span class="pl-s"><span class="pl-pds">"</span>N<span class="pl-pds">"</span></span>;
        <span class="pl-k">private</span> <span class="pl-k">const</span> <span class="pl-k">string</span> WithTrueConstraint = <span class="pl-s"><span class="pl-pds">"</span>T<span class="pl-pds">"</span></span>;
        <span class="pl-k">private</span> <span class="pl-k">const</span> <span class="pl-k">string</span> WithFalseConstraint = <span class="pl-s"><span class="pl-pds">"</span>F<span class="pl-pds">"</span></span>;

        <span class="pl-k">private</span> <span class="pl-k">static</span> IEvaluationEngine engine;

        <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">string</span> answer;

        Establish context = () =&gt;
            {
                engine = <span class="pl-k">new</span> EvaluationEngine();

                engine.Solve&lt;WhatIsTheText, <span class="pl-k">string</span>&gt;()
                    .AggregateWithExpressionAggregator(<span class="pl-k">string</span>.Empty, (aggregate, <span class="pl-k">value</span>) =&gt; aggregate + <span class="pl-k">value</span>)
                    .ByEvaluating((q, p) =&gt; NoConstraint)
                    .When(q =&gt; <span class="pl-c1">false</span>)
                        .ByEvaluating((q, p) =&gt; WithFalseConstraint)
                    .When(q =&gt; <span class="pl-c1">true</span>)
                        .ByEvaluating((q, p) =&gt; WithTrueConstraint);
            };

        Because of = () =&gt;
            {
                answer = engine.Answer(<span class="pl-k">new</span> WhatIsTheText());
            };

        It should_evaluate_expressions_without_constraints = () =&gt; 
            <span class="pl-en">answer.Should</span>()<span class="pl-en">.Contain</span>(NoConstraint);

        It should_evaluate_expressions_with_fulfilled_constraints = () =&gt; 
            <span class="pl-en">answer.Should</span>()<span class="pl-en">.Contain</span>(WithTrueConstraint);

        It should_ignore_expressions_with_constraints_that_are_not_fulfilled = () =&gt; 
            <span class="pl-en">answer.Should</span>()<span class="pl-en">.NotContain</span>(WithFalseConstraint);
    }
}</pre></div>

<p>After automatic conversion:</p>

<div class="highlight highlight-c#"><pre><span class="pl-k">namespace</span> <span class="pl-en">Appccelerate.EvaluationEngine</span>
{
    <span class="pl-k">using</span> FluentAssertions;
    <span class="pl-k">using</span> Xbehave;

    <span class="pl-k">public</span> <span class="pl-k">partial</span> <span class="pl-k">class</span> <span class="pl-en">Question_answering</span>
    {
        [Scenario]
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">When_calling_answer_with_expressions_with_constraints</span>()
        {
        <span class="pl-k">private</span> <span class="pl-k">const</span> <span class="pl-k">string</span> NoConstraint = <span class="pl-s"><span class="pl-pds">"</span>N<span class="pl-pds">"</span></span>;
        <span class="pl-k">private</span> <span class="pl-k">const</span> <span class="pl-k">string</span> WithTrueConstraint = <span class="pl-s"><span class="pl-pds">"</span>T<span class="pl-pds">"</span></span>;
        <span class="pl-k">private</span> <span class="pl-k">const</span> <span class="pl-k">string</span> WithFalseConstraint = <span class="pl-s"><span class="pl-pds">"</span>F<span class="pl-pds">"</span></span>;

            IEvaluationEngine engine = <span class="pl-c1">null</span>;

            <span class="pl-k">string</span> answer = <span class="pl-c1">null</span>;

            <span class="pl-s"><span class="pl-pds">"</span>establish<span class="pl-pds">"</span></span>._(() =&gt;
            {
                engine = <span class="pl-k">new</span> EvaluationEngine();

                engine.Solve&lt;WhatIsTheText, <span class="pl-k">string</span>&gt;()
                    .AggregateWithExpressionAggregator(<span class="pl-k">string</span>.Empty, (aggregate, <span class="pl-k">value</span>) =&gt; aggregate + <span class="pl-k">value</span>)
                    .ByEvaluating((q, p) =&gt; NoConstraint)
                    .When(q =&gt; <span class="pl-c1">false</span>)
                        .ByEvaluating((q, p) =&gt; WithFalseConstraint)
                    .When(q =&gt; <span class="pl-c1">true</span>)
                        .ByEvaluating((q, p) =&gt; WithTrueConstraint);
            });

            <span class="pl-s"><span class="pl-pds">"</span>when calling answer with expressions with constraints<span class="pl-pds">"</span></span>._(() =&gt;
            {
                answer = engine.Answer(<span class="pl-k">new</span> WhatIsTheText());
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should evaluate expressions without constraints<span class="pl-pds">"</span></span>._(() =&gt;
            {
                answer.Should().Contain(NoConstraint);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should evaluate expressions with fulfilled constraints<span class="pl-pds">"</span></span>._(() =&gt;
            {
                answer.Should().Contain(WithTrueConstraint);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should ignore expressions with constraints that are not fulfilled<span class="pl-pds">"</span></span>._(() =&gt;
            {
                answer.Should().NotContain(WithFalseConstraint);
            });
        }
    }
}</pre></div>

<p>Remove <code>private</code> from constant definitions:</p>

<div class="highlight highlight-c#"><pre><span class="pl-k">namespace</span> <span class="pl-en">Appccelerate.EvaluationEngine</span>
{
    <span class="pl-k">using</span> FluentAssertions;
    <span class="pl-k">using</span> Xbehave;

    <span class="pl-k">public</span> <span class="pl-k">partial</span> <span class="pl-k">class</span> <span class="pl-en">Question_answering</span>
    {
        [Scenario]
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">When_calling_answer_with_expressions_with_constraints</span>()
        {
            <span class="pl-k">const</span> <span class="pl-k">string</span> NoConstraint = <span class="pl-s"><span class="pl-pds">"</span>N<span class="pl-pds">"</span></span>;
            <span class="pl-k">const</span> <span class="pl-k">string</span> WithTrueConstraint = <span class="pl-s"><span class="pl-pds">"</span>T<span class="pl-pds">"</span></span>;
            <span class="pl-k">const</span> <span class="pl-k">string</span> WithFalseConstraint = <span class="pl-s"><span class="pl-pds">"</span>F<span class="pl-pds">"</span></span>;

            IEvaluationEngine engine = <span class="pl-c1">null</span>;

            <span class="pl-k">string</span> answer = <span class="pl-c1">null</span>;

            <span class="pl-s"><span class="pl-pds">"</span>establish<span class="pl-pds">"</span></span>._(() =&gt;
            {
                engine = <span class="pl-k">new</span> EvaluationEngine();

                engine.Solve&lt;WhatIsTheText, <span class="pl-k">string</span>&gt;()
                    .AggregateWithExpressionAggregator(<span class="pl-k">string</span>.Empty, (aggregate, <span class="pl-k">value</span>) =&gt; aggregate + <span class="pl-k">value</span>)
                    .ByEvaluating((q, p) =&gt; NoConstraint)
                    .When(q =&gt; <span class="pl-c1">false</span>)
                        .ByEvaluating((q, p) =&gt; WithFalseConstraint)
                    .When(q =&gt; <span class="pl-c1">true</span>)
                        .ByEvaluating((q, p) =&gt; WithTrueConstraint);
            });

            <span class="pl-s"><span class="pl-pds">"</span>when calling answer with expressions with constraints<span class="pl-pds">"</span></span>._(() =&gt;
            {
                answer = engine.Answer(<span class="pl-k">new</span> WhatIsTheText());
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should evaluate expressions without constraints<span class="pl-pds">"</span></span>._(() =&gt;
            {
                answer.Should().Contain(NoConstraint);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should evaluate expressions with fulfilled constraints<span class="pl-pds">"</span></span>._(() =&gt;
            {
                answer.Should().Contain(WithTrueConstraint);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should ignore expressions with constraints that are not fulfilled<span class="pl-pds">"</span></span>._(() =&gt;
            {
                answer.Should().NotContain(WithFalseConstraint);
            });
        }
    }
}</pre></div>

<p>This spec is runnable.</p>

<p>Now let's finish with some clean-up:</p>

<ul>
<li>move locals to method parameters (Ctrl+R, Ctrl+P in R#)</li>
<li>remove partial (not needed in this scenario)</li>
<li>better naming instead of <code>establish</code>
</li>
<li>shorten the scenario name</li>
</ul>

<div class="highlight highlight-c#"><pre><span class="pl-k">namespace</span> <span class="pl-en">Appccelerate.EvaluationEngine</span>
{
    <span class="pl-k">using</span> FluentAssertions;
    <span class="pl-k">using</span> Xbehave;

    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Question_answering</span>
    {
        [Scenario]
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Constraints</span>(
            <span class="pl-k">IEvaluationEngine</span> <span class="pl-smi">engine</span>, 
            <span class="pl-k">string</span> <span class="pl-smi">answer</span>)
        {
            <span class="pl-k">const</span> <span class="pl-k">string</span> NoConstraint = <span class="pl-s"><span class="pl-pds">"</span>N<span class="pl-pds">"</span></span>;
            <span class="pl-k">const</span> <span class="pl-k">string</span> WithTrueConstraint = <span class="pl-s"><span class="pl-pds">"</span>T<span class="pl-pds">"</span></span>;
            <span class="pl-k">const</span> <span class="pl-k">string</span> WithFalseConstraint = <span class="pl-s"><span class="pl-pds">"</span>F<span class="pl-pds">"</span></span>;

            <span class="pl-s"><span class="pl-pds">"</span>establish an evaluation engine with constraint expressions<span class="pl-pds">"</span></span>._(() =&gt;
            {
                engine = <span class="pl-k">new</span> EvaluationEngine();

                engine.Solve&lt;WhatIsTheText, <span class="pl-k">string</span>&gt;()
                    .AggregateWithExpressionAggregator(<span class="pl-k">string</span>.Empty, (aggregate, <span class="pl-k">value</span>) =&gt; aggregate + <span class="pl-k">value</span>)
                    .ByEvaluating((q, p) =&gt; NoConstraint)
                    .When(q =&gt; <span class="pl-c1">false</span>)
                        .ByEvaluating((q, p) =&gt; WithFalseConstraint)
                    .When(q =&gt; <span class="pl-c1">true</span>)
                        .ByEvaluating((q, p) =&gt; WithTrueConstraint);
            });

            <span class="pl-s"><span class="pl-pds">"</span>when calling answer with expressions with constraints<span class="pl-pds">"</span></span>._(() =&gt;
            {
                answer = engine.Answer(<span class="pl-k">new</span> WhatIsTheText());
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should evaluate expressions without constraints<span class="pl-pds">"</span></span>._(() =&gt;
            {
                answer.Should().Contain(NoConstraint);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should evaluate expressions with fulfilled constraints<span class="pl-pds">"</span></span>._(() =&gt;
            {
                answer.Should().Contain(WithTrueConstraint);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should ignore expressions with constraints that are not fulfilled<span class="pl-pds">"</span></span>._(() =&gt;
            {
                answer.Should().NotContain(WithFalseConstraint);
            });
        }
    }
}</pre></div>

<p>Finished!</p>

<h2>
<a id="converting-specs-with-base-classes" class="anchor" href="#converting-specs-with-base-classes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Converting Specs with base classes</h2>

<p>If you used base classes in your MSpec specifications, then you need to prepare your classes first.</p>

<p>There are several possibilities:</p>

<ul>
<li>inline all code in the base class in the derived classes (probably introducing a lot of code duplication)</li>
<li>move the code from the base class into a helper class that you call from within the establish of the derived classes (no code duplication)</li>
<li>convert the derived classes and the base class and move the code from the base class as a <code>Background</code> step into the merged class holding all scenarios. (see below)</li>
</ul>

<div class="highlight highlight-c#"><pre><span class="pl-k">namespace</span> <span class="pl-en">Appccelerate.EvaluationEngine</span>
{
    <span class="pl-k">using</span> System;

    <span class="pl-k">using</span> FluentAssertions;

    <span class="pl-k">using</span> Machine.Specifications;

    [Subject(Concern.HierarchicalEngines)]
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">When_calling_answer_on_a_child_evaluation_engine</span> : <span class="pl-k">HierarchicalEngineContext</span>
    {
        <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">string</span> childAnswer;

        Because of = () =&gt;
            {
                childAnswer = ChildEngine.Answer(<span class="pl-k">new</span> Question());
            };

        It should_override_parent_aggregator_with_child_aggregator = () =&gt; 
            <span class="pl-en">childAnswer.Should</span>()<span class="pl-en">.Contain</span>(ChildAggregator);

        It should_use_expressions_from_child_and_parent = () =&gt; 
            childAnswer
                .<span class="pl-en">Should</span>()<span class="pl-en">.Contain</span>(ParentExpression)
                <span class="pl-en">.And.Contain</span>(ChildExpression);

        It should_evaluate_expressions_from_parent_first = () =&gt;
            <span class="pl-en">childAnswer.EndsWith</span>(ParentExpression + ChildExpression, StringComparison.Ordinal)
                <span class="pl-en">.Should</span>()<span class="pl-en">.BeTrue</span>();
    }

    [Subject(Concern.HierarchicalEngines)]
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">When_calling_answer_on_a_parent_evaluation_engine</span> : <span class="pl-k">HierarchicalEngineContext</span>
    {
        <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">string</span> parentAnswer;

        Because of = () =&gt;
            {
                parentAnswer = ParentEngine.Answer(<span class="pl-k">new</span> Question());
            };

        It should_use_parent_aggregator = () =&gt; 
            <span class="pl-en">parentAnswer.Should</span>()<span class="pl-en">.Contain</span>(ParentAggregator);

        It should_use_expressions_only_from_parent = () =&gt; 
            <span class="pl-en">parentAnswer.Should</span>()<span class="pl-en">.NotContain</span>(ChildExpression);
    }

    [Subject(Concern.HierarchicalEngines)]
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">HierarchicalEngineContext</span>
    {
        <span class="pl-k">protected</span> <span class="pl-k">const</span> <span class="pl-k">string</span> ParentAggregator = <span class="pl-s"><span class="pl-pds">"</span>parentAggregator<span class="pl-pds">"</span></span>;
        <span class="pl-k">protected</span> <span class="pl-k">const</span> <span class="pl-k">string</span> ChildAggregator = <span class="pl-s"><span class="pl-pds">"</span>childAggregator<span class="pl-pds">"</span></span>;
        <span class="pl-k">protected</span> <span class="pl-k">const</span> <span class="pl-k">string</span> ParentExpression = <span class="pl-s"><span class="pl-pds">"</span>parentExpression<span class="pl-pds">"</span></span>;
        <span class="pl-k">protected</span> <span class="pl-k">const</span> <span class="pl-k">string</span> ChildExpression = <span class="pl-s"><span class="pl-pds">"</span>childExpression<span class="pl-pds">"</span></span>;

        Establish context = () =&gt;
        {
            ParentEngine = <span class="pl-k">new</span> EvaluationEngine();
            ChildEngine = <span class="pl-k">new</span> EvaluationEngine(ParentEngine);

            ParentEngine.Solve&lt;Question, <span class="pl-k">string</span>&gt;()
            .AggregateWithExpressionAggregator(ParentAggregator, (aggregate, <span class="pl-k">value</span>) =&gt; aggregate + <span class="pl-k">value</span>)
            .ByEvaluating((q, p) =&gt; ParentExpression);

            ChildEngine.Solve&lt;Question, <span class="pl-k">string</span>&gt;()
                .AggregateWithExpressionAggregator(ChildAggregator, (aggregate, <span class="pl-k">value</span>) =&gt; aggregate + <span class="pl-k">value</span>)
                .ByEvaluating((q, p) =&gt; ChildExpression);
        };

        <span class="pl-k">protected</span> <span class="pl-k">static</span> IEvaluationEngine <span class="pl-en">ParentEngine</span> { <span class="pl-k">get</span>; <span class="pl-k">private</span> <span class="pl-k">set</span>; }

        <span class="pl-k">protected</span> <span class="pl-k">static</span> IEvaluationEngine <span class="pl-en">ChildEngine</span> { <span class="pl-k">get</span>; <span class="pl-k">private</span> <span class="pl-k">set</span>; }

        <span class="pl-k">protected</span> <span class="pl-k">class</span> <span class="pl-en">Question</span> : <span class="pl-k">IQuestion</span>&lt;<span class="pl-k">string</span>&gt;
        {
            <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Describe</span>()
            {
                <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>test question<span class="pl-pds">"</span></span>;
            }
        }
    }
}</pre></div>

<p>After automatic conversion:</p>

<div class="highlight highlight-c#"><pre><span class="pl-k">namespace</span> <span class="pl-en">Appccelerate.EvaluationEngine</span>
{
    <span class="pl-k">using</span> System;

    <span class="pl-k">using</span> FluentAssertions;

    <span class="pl-k">using</span> Xbehave;

    <span class="pl-k">public</span> <span class="pl-k">partial</span> <span class="pl-k">class</span> <span class="pl-en">Hierarchical_evaluation_engines</span>
    {
        [Scenario]
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">When_calling_answer_on_a_child_evaluation_engine</span>()
        {
            <span class="pl-k">string</span> childAnswer = <span class="pl-c1">null</span>;

            <span class="pl-s"><span class="pl-pds">"</span>when calling answer on a child evaluation engine<span class="pl-pds">"</span></span>._(() =&gt;
            {
                childAnswer = ChildEngine.Answer(<span class="pl-k">new</span> Question());
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should override parent aggregator with child aggregator<span class="pl-pds">"</span></span>._(() =&gt;
            {
                childAnswer.Should().Contain(ChildAggregator);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should use expressions from child and parent<span class="pl-pds">"</span></span>._(() =&gt;
            {
                childAnswer
                .Should().Contain(ParentExpression)
                .And.Contain(ChildExpression);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should evaluate expressions from parent first<span class="pl-pds">"</span></span>._(() =&gt;
            {
                childAnswer.EndsWith(ParentExpression + ChildExpression, StringComparison.Ordinal)
                .Should().BeTrue();
            });
    }

    <span class="pl-k">public</span> <span class="pl-k">partial</span> <span class="pl-k">class</span> <span class="pl-en">Hierarchical_evaluation_engines</span>
    {
        [Scenario]
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">When_calling_answer_on_a_parent_evaluation_engine</span>()
        {
            <span class="pl-k">string</span> parentAnswer = <span class="pl-c1">null</span>;

            <span class="pl-s"><span class="pl-pds">"</span>when calling answer on a child evaluation engine<span class="pl-pds">"</span></span>._(() =&gt;
            {
                parentAnswer = ParentEngine.Answer(<span class="pl-k">new</span> Question());
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should use parent aggregator<span class="pl-pds">"</span></span>._(() =&gt;
            {
                parentAnswer.Should().Contain(ParentAggregator);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should use expressions only from parent<span class="pl-pds">"</span></span>._(() =&gt;
            {
                parentAnswer.Should().NotContain(ChildExpression);
            });
    }

    <span class="pl-k">public</span> <span class="pl-k">partial</span> <span class="pl-k">class</span> <span class="pl-en">Hierarchical_evaluation_engines</span>
    {
        [Scenario]
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">HierarchicalEngineContext</span>()
        {
        <span class="pl-k">protected</span> <span class="pl-k">const</span> <span class="pl-k">string</span> ParentAggregator = <span class="pl-s"><span class="pl-pds">"</span>parentAggregator<span class="pl-pds">"</span></span>;
        <span class="pl-k">protected</span> <span class="pl-k">const</span> <span class="pl-k">string</span> ChildAggregator = <span class="pl-s"><span class="pl-pds">"</span>childAggregator<span class="pl-pds">"</span></span>;
        <span class="pl-k">protected</span> <span class="pl-k">const</span> <span class="pl-k">string</span> ParentExpression = <span class="pl-s"><span class="pl-pds">"</span>parentExpression<span class="pl-pds">"</span></span>;
        <span class="pl-k">protected</span> <span class="pl-k">const</span> <span class="pl-k">string</span> ChildExpression = <span class="pl-s"><span class="pl-pds">"</span>childExpression<span class="pl-pds">"</span></span>;

            <span class="pl-s"><span class="pl-pds">"</span>establish<span class="pl-pds">"</span></span>._(() =&gt;
            {
            ParentEngine = <span class="pl-k">new</span> EvaluationEngine();
            ChildEngine = <span class="pl-k">new</span> EvaluationEngine(ParentEngine);

            ParentEngine.Solve&lt;Question, <span class="pl-k">string</span>&gt;()
            .AggregateWithExpressionAggregator(ParentAggregator, (aggregate, <span class="pl-k">value</span>) =&gt; aggregate + <span class="pl-k">value</span>)
            .ByEvaluating((q, p) =&gt; ParentExpression);

            ChildEngine.Solve&lt;Question, <span class="pl-k">string</span>&gt;()
                .AggregateWithExpressionAggregator(ChildAggregator, (aggregate, <span class="pl-k">value</span>) =&gt; aggregate + <span class="pl-k">value</span>)
                .ByEvaluating((q, p) =&gt; ChildExpression);
        });
        }
        }
        }

        <span class="pl-k">protected</span> <span class="pl-k">static</span> IEvaluationEngine <span class="pl-en">ParentEngine</span> { <span class="pl-k">get</span>; <span class="pl-k">private</span> <span class="pl-k">set</span>; }

        <span class="pl-k">protected</span> <span class="pl-k">static</span> IEvaluationEngine <span class="pl-en">ChildEngine</span> { <span class="pl-k">get</span>; <span class="pl-k">private</span> <span class="pl-k">set</span>; }

        <span class="pl-k">protected</span> <span class="pl-k">class</span> <span class="pl-en">Question</span> : <span class="pl-k">IQuestion</span>&lt;<span class="pl-k">string</span>&gt;
        {
            <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Describe</span>()
            {
                <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>test question<span class="pl-pds">"</span></span>;
            }
        }
    }
}</pre></div>

<p>Make it runnable:</p>

<ul>
<li>remove the second partial class definition <code>public partial class Hierarchical_evaluation_engines {</code> so that you just have a single class with Scenarios.</li>
<li>move the fields and nested classes into the class holding the Scenarios</li>
<li>move the <code>establish</code> from the base class into the class holding the Scenarios as a <code>Background</code> step</li>
</ul>

<div class="highlight highlight-c#"><pre><span class="pl-k">namespace</span> <span class="pl-en">Appccelerate.EvaluationEngine</span>
{
    <span class="pl-k">using</span> System;

    <span class="pl-k">using</span> FluentAssertions;

    <span class="pl-k">using</span> Xbehave;

    <span class="pl-k">public</span> <span class="pl-k">partial</span> <span class="pl-k">class</span> <span class="pl-en">Hierarchical_evaluation_engines</span>
    {
        <span class="pl-k">protected</span> <span class="pl-k">const</span> <span class="pl-k">string</span> ParentAggregator = <span class="pl-s"><span class="pl-pds">"</span>parentAggregator<span class="pl-pds">"</span></span>;
        <span class="pl-k">protected</span> <span class="pl-k">const</span> <span class="pl-k">string</span> ChildAggregator = <span class="pl-s"><span class="pl-pds">"</span>childAggregator<span class="pl-pds">"</span></span>;
        <span class="pl-k">protected</span> <span class="pl-k">const</span> <span class="pl-k">string</span> ParentExpression = <span class="pl-s"><span class="pl-pds">"</span>parentExpression<span class="pl-pds">"</span></span>;
        <span class="pl-k">protected</span> <span class="pl-k">const</span> <span class="pl-k">string</span> ChildExpression = <span class="pl-s"><span class="pl-pds">"</span>childExpression<span class="pl-pds">"</span></span>;

        [Background]
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Background</span>()
        {
            <span class="pl-s"><span class="pl-pds">"</span>establish<span class="pl-pds">"</span></span>._(() =&gt;
            {
            ParentEngine = <span class="pl-k">new</span> EvaluationEngine();
            ChildEngine = <span class="pl-k">new</span> EvaluationEngine(ParentEngine);

            ParentEngine.Solve&lt;Question, <span class="pl-k">string</span>&gt;()
            .AggregateWithExpressionAggregator(ParentAggregator, (aggregate, <span class="pl-k">value</span>) =&gt; aggregate + <span class="pl-k">value</span>)
            .ByEvaluating((q, p) =&gt; ParentExpression);

            ChildEngine.Solve&lt;Question, <span class="pl-k">string</span>&gt;()
                .AggregateWithExpressionAggregator(ChildAggregator, (aggregate, <span class="pl-k">value</span>) =&gt; aggregate + <span class="pl-k">value</span>)
                .ByEvaluating((q, p) =&gt; ChildExpression);
            });
        }

        <span class="pl-k">protected</span> <span class="pl-k">static</span> IEvaluationEngine <span class="pl-en">ParentEngine</span> { <span class="pl-k">get</span>; <span class="pl-k">private</span> <span class="pl-k">set</span>; }

        <span class="pl-k">protected</span> <span class="pl-k">static</span> IEvaluationEngine <span class="pl-en">ChildEngine</span> { <span class="pl-k">get</span>; <span class="pl-k">private</span> <span class="pl-k">set</span>; }

        <span class="pl-k">protected</span> <span class="pl-k">class</span> <span class="pl-en">Question</span> : <span class="pl-k">IQuestion</span>&lt;<span class="pl-k">string</span>&gt;
        {
            <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Describe</span>()
            {
                <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>test question<span class="pl-pds">"</span></span>;
            }
        }

        [Scenario]
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">When_calling_answer_on_a_child_evaluation_engine</span>()
        {
            <span class="pl-k">string</span> childAnswer = <span class="pl-c1">null</span>;

            <span class="pl-s"><span class="pl-pds">"</span>when calling answer on a child evaluation engine<span class="pl-pds">"</span></span>._(() =&gt;
            {
                childAnswer = ChildEngine.Answer(<span class="pl-k">new</span> Question());
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should override parent aggregator with child aggregator<span class="pl-pds">"</span></span>._(() =&gt;
            {
                childAnswer.Should().Contain(ChildAggregator);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should use expressions from child and parent<span class="pl-pds">"</span></span>._(() =&gt;
            {
                childAnswer
                .Should().Contain(ParentExpression)
                .And.Contain(ChildExpression);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should evaluate expressions from parent first<span class="pl-pds">"</span></span>._(() =&gt;
            {
                childAnswer.EndsWith(ParentExpression + ChildExpression, StringComparison.Ordinal)
                .Should().BeTrue();
            });
    }

        [Scenario]
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">When_calling_answer_on_a_parent_evaluation_engine</span>()
        {
            <span class="pl-k">string</span> parentAnswer = <span class="pl-c1">null</span>;

            <span class="pl-s"><span class="pl-pds">"</span>when calling answer on a child evaluation engine<span class="pl-pds">"</span></span>._(() =&gt;
            {
                parentAnswer = ParentEngine.Answer(<span class="pl-k">new</span> Question());
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should use parent aggregator<span class="pl-pds">"</span></span>._(() =&gt;
            {
                parentAnswer.Should().Contain(ParentAggregator);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should use expressions only from parent<span class="pl-pds">"</span></span>._(() =&gt;
            {
                parentAnswer.Should().NotContain(ChildExpression);
            });

        }
    }
}</pre></div>

<p>And then some clean-up:</p>

<ul>
<li>remove partial</li>
<li>remove unnecessary <code>protected</code>
</li>
<li>better naming of establish in Background step, of class holding scenarios and method names of scenarios</li>
<li>move fields and nested class to a nicer place inside class holding Scenarios</li>
<li>remove unnecessary white space</li>
</ul>

<div class="highlight highlight-c#"><pre><span class="pl-k">namespace</span> <span class="pl-en">Appccelerate.EvaluationEngine</span>
{
    <span class="pl-k">using</span> System;

    <span class="pl-k">using</span> FluentAssertions;

    <span class="pl-k">using</span> Xbehave;

    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">HierarchicalEvaluationEngines</span>
    {
        <span class="pl-k">const</span> <span class="pl-k">string</span> ParentAggregator = <span class="pl-s"><span class="pl-pds">"</span>parentAggregator<span class="pl-pds">"</span></span>;
        <span class="pl-k">const</span> <span class="pl-k">string</span> ChildAggregator = <span class="pl-s"><span class="pl-pds">"</span>childAggregator<span class="pl-pds">"</span></span>;
        <span class="pl-k">const</span> <span class="pl-k">string</span> ParentExpression = <span class="pl-s"><span class="pl-pds">"</span>parentExpression<span class="pl-pds">"</span></span>;
        <span class="pl-k">const</span> <span class="pl-k">string</span> ChildExpression = <span class="pl-s"><span class="pl-pds">"</span>childExpression<span class="pl-pds">"</span></span>;

        <span class="pl-k">private</span> <span class="pl-k">static</span> IEvaluationEngine <span class="pl-en">ParentEngine</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
        <span class="pl-k">private</span> <span class="pl-k">static</span> IEvaluationEngine <span class="pl-en">ChildEngine</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

        [Background]
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Background</span>()
        {
            <span class="pl-s"><span class="pl-pds">"</span>establish a hierarchical evaluation engine<span class="pl-pds">"</span></span>._(() =&gt;
            {
                ParentEngine = <span class="pl-k">new</span> EvaluationEngine();
                ChildEngine = <span class="pl-k">new</span> EvaluationEngine(ParentEngine);

                ParentEngine.Solve&lt;Question, <span class="pl-k">string</span>&gt;()
                .AggregateWithExpressionAggregator(ParentAggregator, (aggregate, <span class="pl-k">value</span>) =&gt; aggregate + <span class="pl-k">value</span>)
                .ByEvaluating((q, p) =&gt; ParentExpression);

                ChildEngine.Solve&lt;Question, <span class="pl-k">string</span>&gt;()
                    .AggregateWithExpressionAggregator(ChildAggregator, (aggregate, <span class="pl-k">value</span>) =&gt; aggregate + <span class="pl-k">value</span>)
                    .ByEvaluating((q, p) =&gt; ChildExpression);
            });
        }

        [Scenario]
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">QuestionChild</span>(<span class="pl-k">string</span> <span class="pl-smi">childAnswer</span>)
        {
            <span class="pl-s"><span class="pl-pds">"</span>when calling answer on a child evaluation engine<span class="pl-pds">"</span></span>._(() =&gt;
            {
                childAnswer = ChildEngine.Answer(<span class="pl-k">new</span> Question());
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should override parent aggregator with child aggregator<span class="pl-pds">"</span></span>._(() =&gt;
            {
                childAnswer.Should().Contain(ChildAggregator);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should use expressions from child and parent<span class="pl-pds">"</span></span>._(() =&gt;
            {
                childAnswer
                .Should().Contain(ParentExpression)
                .And.Contain(ChildExpression);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should evaluate expressions from parent first<span class="pl-pds">"</span></span>._(() =&gt;
            {
                childAnswer.EndsWith(ParentExpression + ChildExpression, StringComparison.Ordinal)
                .Should().BeTrue();
            });
        }

        [Scenario]
        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">QuestionParent</span>(<span class="pl-k">string</span> <span class="pl-smi">parentAnswer</span>)
        {
            <span class="pl-s"><span class="pl-pds">"</span>when calling answer on a child evaluation engine<span class="pl-pds">"</span></span>._(() =&gt;
            {
                parentAnswer = ParentEngine.Answer(<span class="pl-k">new</span> Question());
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should use parent aggregator<span class="pl-pds">"</span></span>._(() =&gt;
            {
                parentAnswer.Should().Contain(ParentAggregator);
            });

            <span class="pl-s"><span class="pl-pds">"</span>it should use expressions only from parent<span class="pl-pds">"</span></span>._(() =&gt;
            {
                parentAnswer.Should().NotContain(ChildExpression);
            });
        }

        <span class="pl-k">private</span> <span class="pl-k">class</span> <span class="pl-en">Question</span> : <span class="pl-k">IQuestion</span>&lt;<span class="pl-k">string</span>&gt;
        {
            <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Describe</span>()
            {
                <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>test question<span class="pl-pds">"</span></span>;
            }
        }
    }
}</pre></div>

<p>Be happy!</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/ursenzler/MSpec2xBehaveConverter">Mspec2xbehaveconverter</a> is maintained by <a href="https://github.com/ursenzler">ursenzler</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

