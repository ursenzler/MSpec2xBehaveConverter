<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Mspec2xbehaveconverter by ursenzler</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Mspec2xbehaveconverter</h1>
      <h2 class="project-tagline">Helps to migrate from Machine.Specifications to xBehave</h2>
      <a href="https://github.com/ursenzler/MSpec2xBehaveConverter" class="btn">View on GitHub</a>
      <a href="https://github.com/ursenzler/MSpec2xBehaveConverter/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/ursenzler/MSpec2xBehaveConverter/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="machinespecifications-to-xbehavenet-converter" class="anchor" href="#machinespecifications-to-xbehavenet-converter" aria-hidden="true"><span class="octicon octicon-link"></span></a>Machine.Specifications to xBehave.net converter</h1>

<p>Helps to migrate specifications or tests made with MSpec to xBehave.net by doing all the syntax replacement for you.</p>

<h1>
<a id="scenarios" class="anchor" href="#scenarios" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scenarios</h1>

<p>See samples on how to migrate specifications.</p>

<h2>
<a id="happy-case" class="anchor" href="#happy-case" aria-hidden="true"><span class="octicon octicon-link"></span></a>Happy case</h2>

<p>MSpec:</p>

<pre><code>namespace Appccelerate.EvaluationEngine
{
    using FluentAssertions;
    using Machine.Specifications;

    [Subject("Question answering")]
    public class When_calling_answer_with_expressions_with_constraints
    {
        private const string NoConstraint = "N";
        private const string WithTrueConstraint = "T";
        private const string WithFalseConstraint = "F";

        private static IEvaluationEngine engine;

        private static string answer;

        Establish context = () =&gt;
            {
                engine = new EvaluationEngine();

                engine.Solve&lt;WhatIsTheText, string&gt;()
                    .AggregateWithExpressionAggregator(string.Empty, (aggregate, value) =&gt; aggregate + value)
                    .ByEvaluating((q, p) =&gt; NoConstraint)
                    .When(q =&gt; false)
                        .ByEvaluating((q, p) =&gt; WithFalseConstraint)
                    .When(q =&gt; true)
                        .ByEvaluating((q, p) =&gt; WithTrueConstraint);
            };

        Because of = () =&gt;
            {
                answer = engine.Answer(new WhatIsTheText());
            };

        It should_evaluate_expressions_without_constraints = () =&gt; 
            answer.Should().Contain(NoConstraint);

        It should_evaluate_expressions_with_fulfilled_constraints = () =&gt; 
            answer.Should().Contain(WithTrueConstraint);

        It should_ignore_expressions_with_constraints_that_are_not_fulfilled = () =&gt; 
            answer.Should().NotContain(WithFalseConstraint);
    }
}
</code></pre>

<p>After automatic conversion:</p>

<pre><code>namespace Appccelerate.EvaluationEngine
{
    using FluentAssertions;
    using Xbehave;

    public partial class Question_answering
    {
        [Scenario]
        public void When_calling_answer_with_expressions_with_constraints()
        {
        private const string NoConstraint = "N";
        private const string WithTrueConstraint = "T";
        private const string WithFalseConstraint = "F";

            IEvaluationEngine engine = null;

            string answer = null;

            "establish"._(() =&gt;
            {
                engine = new EvaluationEngine();

                engine.Solve&lt;WhatIsTheText, string&gt;()
                    .AggregateWithExpressionAggregator(string.Empty, (aggregate, value) =&gt; aggregate + value)
                    .ByEvaluating((q, p) =&gt; NoConstraint)
                    .When(q =&gt; false)
                        .ByEvaluating((q, p) =&gt; WithFalseConstraint)
                    .When(q =&gt; true)
                        .ByEvaluating((q, p) =&gt; WithTrueConstraint);
            });

            "when calling answer with expressions with constraints"._(() =&gt;
            {
                answer = engine.Answer(new WhatIsTheText());
            });

            "it should evaluate expressions without constraints"._(() =&gt;
            {
                answer.Should().Contain(NoConstraint);
            });

            "it should evaluate expressions with fulfilled constraints"._(() =&gt;
            {
                answer.Should().Contain(WithTrueConstraint);
            });

            "it should ignore expressions with constraints that are not fulfilled"._(() =&gt;
            {
                answer.Should().NotContain(WithFalseConstraint);
            });
        }
    }
}
</code></pre>

<p>Remove <code>private</code> from constant definitions:</p>

<pre><code>namespace Appccelerate.EvaluationEngine
{
    using FluentAssertions;
    using Xbehave;

    public partial class Question_answering
    {
        [Scenario]
        public void When_calling_answer_with_expressions_with_constraints()
        {
            const string NoConstraint = "N";
            const string WithTrueConstraint = "T";
            const string WithFalseConstraint = "F";

            IEvaluationEngine engine = null;

            string answer = null;

            "establish"._(() =&gt;
            {
                engine = new EvaluationEngine();

                engine.Solve&lt;WhatIsTheText, string&gt;()
                    .AggregateWithExpressionAggregator(string.Empty, (aggregate, value) =&gt; aggregate + value)
                    .ByEvaluating((q, p) =&gt; NoConstraint)
                    .When(q =&gt; false)
                        .ByEvaluating((q, p) =&gt; WithFalseConstraint)
                    .When(q =&gt; true)
                        .ByEvaluating((q, p) =&gt; WithTrueConstraint);
            });

            "when calling answer with expressions with constraints"._(() =&gt;
            {
                answer = engine.Answer(new WhatIsTheText());
            });

            "it should evaluate expressions without constraints"._(() =&gt;
            {
                answer.Should().Contain(NoConstraint);
            });

            "it should evaluate expressions with fulfilled constraints"._(() =&gt;
            {
                answer.Should().Contain(WithTrueConstraint);
            });

            "it should ignore expressions with constraints that are not fulfilled"._(() =&gt;
            {
                answer.Should().NotContain(WithFalseConstraint);
            });
        }
    }
}
</code></pre>

<p>This spec is runnable.</p>

<p>Now let's finish with some clean-up:</p>

<ul>
<li>move locals to method parameters (Ctrl+R, Ctrl+P in R#)</li>
<li>remove partial (not needed in this scenario)</li>
<li>better naming instead of <code>establish</code>
</li>
<li>shorten the scenario name</li>
</ul>

<pre><code>namespace Appccelerate.EvaluationEngine
{
    using FluentAssertions;
    using Xbehave;

    public class Question_answering
    {
        [Scenario]
        public void Constraints(
            IEvaluationEngine engine, 
            string answer)
        {
            const string NoConstraint = "N";
            const string WithTrueConstraint = "T";
            const string WithFalseConstraint = "F";

            "establish an evaluation engine with constraint expressions"._(() =&gt;
            {
                engine = new EvaluationEngine();

                engine.Solve&lt;WhatIsTheText, string&gt;()
                    .AggregateWithExpressionAggregator(string.Empty, (aggregate, value) =&gt; aggregate + value)
                    .ByEvaluating((q, p) =&gt; NoConstraint)
                    .When(q =&gt; false)
                        .ByEvaluating((q, p) =&gt; WithFalseConstraint)
                    .When(q =&gt; true)
                        .ByEvaluating((q, p) =&gt; WithTrueConstraint);
            });

            "when calling answer with expressions with constraints"._(() =&gt;
            {
                answer = engine.Answer(new WhatIsTheText());
            });

            "it should evaluate expressions without constraints"._(() =&gt;
            {
                answer.Should().Contain(NoConstraint);
            });

            "it should evaluate expressions with fulfilled constraints"._(() =&gt;
            {
                answer.Should().Contain(WithTrueConstraint);
            });

            "it should ignore expressions with constraints that are not fulfilled"._(() =&gt;
            {
                answer.Should().NotContain(WithFalseConstraint);
            });
        }
    }
}
</code></pre>

<p>Finished!</p>

<h2>
<a id="converting-specs-with-base-classes" class="anchor" href="#converting-specs-with-base-classes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Converting Specs with base classes</h2>

<p>If you used base classes in your MSpec specifications, then you need to prepare your classes first.</p>

<p>There are several possibilities:</p>

<ul>
<li>inline all code in the base class in the derived classes (probably introducing a lot of code duplication)</li>
<li>move the code from the base class into a helper class that you call from within the establish of the derived classes (no code duplication)</li>
<li>convert the derived classes and the base class and move the code from the base class as a <code>Background</code> step into the merged class holding all scenarios. (see below)</li>
</ul>

<pre><code>namespace Appccelerate.EvaluationEngine
{
    using System;

    using FluentAssertions;

    using Machine.Specifications;

    [Subject(Concern.HierarchicalEngines)]
    public class When_calling_answer_on_a_child_evaluation_engine : HierarchicalEngineContext
    {
        private static string childAnswer;

        Because of = () =&gt;
            {
                childAnswer = ChildEngine.Answer(new Question());
            };

        It should_override_parent_aggregator_with_child_aggregator = () =&gt; 
            childAnswer.Should().Contain(ChildAggregator);

        It should_use_expressions_from_child_and_parent = () =&gt; 
            childAnswer
                .Should().Contain(ParentExpression)
                .And.Contain(ChildExpression);

        It should_evaluate_expressions_from_parent_first = () =&gt;
            childAnswer.EndsWith(ParentExpression + ChildExpression, StringComparison.Ordinal)
                .Should().BeTrue();
    }

    [Subject(Concern.HierarchicalEngines)]
    public class When_calling_answer_on_a_parent_evaluation_engine : HierarchicalEngineContext
    {
        private static string parentAnswer;

        Because of = () =&gt;
            {
                parentAnswer = ParentEngine.Answer(new Question());
            };

        It should_use_parent_aggregator = () =&gt; 
            parentAnswer.Should().Contain(ParentAggregator);

        It should_use_expressions_only_from_parent = () =&gt; 
            parentAnswer.Should().NotContain(ChildExpression);
    }

    [Subject(Concern.HierarchicalEngines)]
    public class HierarchicalEngineContext
    {
        protected const string ParentAggregator = "parentAggregator";
        protected const string ChildAggregator = "childAggregator";
        protected const string ParentExpression = "parentExpression";
        protected const string ChildExpression = "childExpression";

        Establish context = () =&gt;
        {
            ParentEngine = new EvaluationEngine();
            ChildEngine = new EvaluationEngine(ParentEngine);

            ParentEngine.Solve&lt;Question, string&gt;()
            .AggregateWithExpressionAggregator(ParentAggregator, (aggregate, value) =&gt; aggregate + value)
            .ByEvaluating((q, p) =&gt; ParentExpression);

            ChildEngine.Solve&lt;Question, string&gt;()
                .AggregateWithExpressionAggregator(ChildAggregator, (aggregate, value) =&gt; aggregate + value)
                .ByEvaluating((q, p) =&gt; ChildExpression);
        };

        protected static IEvaluationEngine ParentEngine { get; private set; }

        protected static IEvaluationEngine ChildEngine { get; private set; }

        protected class Question : IQuestion&lt;string&gt;
        {
            public string Describe()
            {
                return "test question";
            }
        }
    }
}
</code></pre>

<p>After automatic convertion:</p>

<pre><code>namespace Appccelerate.EvaluationEngine
{
    using System;

    using FluentAssertions;

    using Xbehave;

    public partial class Hierarchical_evaluation_engines
    {
        [Scenario]
        public void When_calling_answer_on_a_child_evaluation_engine()
        {
            string childAnswer = null;

            "when calling answer on a child evaluation engine"._(() =&gt;
            {
                childAnswer = ChildEngine.Answer(new Question());
            });

            "it should override parent aggregator with child aggregator"._(() =&gt;
            {
                childAnswer.Should().Contain(ChildAggregator);
            });

            "it should use expressions from child and parent"._(() =&gt;
            {
                childAnswer
                .Should().Contain(ParentExpression)
                .And.Contain(ChildExpression);
            });

            "it should evaluate expressions from parent first"._(() =&gt;
            {
                childAnswer.EndsWith(ParentExpression + ChildExpression, StringComparison.Ordinal)
                .Should().BeTrue();
            });
    }

    public partial class Hierarchical_evaluation_engines
    {
        [Scenario]
        public void When_calling_answer_on_a_parent_evaluation_engine()
        {
            string parentAnswer = null;

            "when calling answer on a child evaluation engine"._(() =&gt;
            {
                parentAnswer = ParentEngine.Answer(new Question());
            });

            "it should use parent aggregator"._(() =&gt;
            {
                parentAnswer.Should().Contain(ParentAggregator);
            });

            "it should use expressions only from parent"._(() =&gt;
            {
                parentAnswer.Should().NotContain(ChildExpression);
            });
    }

    public partial class Hierarchical_evaluation_engines
    {
        [Scenario]
        public void HierarchicalEngineContext()
        {
        protected const string ParentAggregator = "parentAggregator";
        protected const string ChildAggregator = "childAggregator";
        protected const string ParentExpression = "parentExpression";
        protected const string ChildExpression = "childExpression";

            "establish"._(() =&gt;
            {
            ParentEngine = new EvaluationEngine();
            ChildEngine = new EvaluationEngine(ParentEngine);

            ParentEngine.Solve&lt;Question, string&gt;()
            .AggregateWithExpressionAggregator(ParentAggregator, (aggregate, value) =&gt; aggregate + value)
            .ByEvaluating((q, p) =&gt; ParentExpression);

            ChildEngine.Solve&lt;Question, string&gt;()
                .AggregateWithExpressionAggregator(ChildAggregator, (aggregate, value) =&gt; aggregate + value)
                .ByEvaluating((q, p) =&gt; ChildExpression);
        });
        }
        }
        }

        protected static IEvaluationEngine ParentEngine { get; private set; }

        protected static IEvaluationEngine ChildEngine { get; private set; }

        protected class Question : IQuestion&lt;string&gt;
        {
            public string Describe()
            {
                return "test question";
            }
        }
    }
}
</code></pre>

<p>Make it runnable:</p>

<ul>
<li>remove the second partial class definition <code>public partial class Hierarchical_evaluation_engines {</code> so that you just have a single class with Scenarios.</li>
<li>move the fields and nested classes into the class holding the Scenarios</li>
<li>move the <code>establish</code> from the base class into the class holding the Scenarios as a <code>Background</code> step</li>
</ul>

<pre><code>namespace Appccelerate.EvaluationEngine
{
    using System;

    using FluentAssertions;

    using Xbehave;

    public partial class Hierarchical_evaluation_engines
    {
        protected const string ParentAggregator = "parentAggregator";
        protected const string ChildAggregator = "childAggregator";
        protected const string ParentExpression = "parentExpression";
        protected const string ChildExpression = "childExpression";

        [Background]
        public void Background()
        {
            "establish"._(() =&gt;
            {
            ParentEngine = new EvaluationEngine();
            ChildEngine = new EvaluationEngine(ParentEngine);

            ParentEngine.Solve&lt;Question, string&gt;()
            .AggregateWithExpressionAggregator(ParentAggregator, (aggregate, value) =&gt; aggregate + value)
            .ByEvaluating((q, p) =&gt; ParentExpression);

            ChildEngine.Solve&lt;Question, string&gt;()
                .AggregateWithExpressionAggregator(ChildAggregator, (aggregate, value) =&gt; aggregate + value)
                .ByEvaluating((q, p) =&gt; ChildExpression);
            });
        }

        protected static IEvaluationEngine ParentEngine { get; private set; }

        protected static IEvaluationEngine ChildEngine { get; private set; }

        protected class Question : IQuestion&lt;string&gt;
        {
            public string Describe()
            {
                return "test question";
            }
        }

        [Scenario]
        public void When_calling_answer_on_a_child_evaluation_engine()
        {
            string childAnswer = null;

            "when calling answer on a child evaluation engine"._(() =&gt;
            {
                childAnswer = ChildEngine.Answer(new Question());
            });

            "it should override parent aggregator with child aggregator"._(() =&gt;
            {
                childAnswer.Should().Contain(ChildAggregator);
            });

            "it should use expressions from child and parent"._(() =&gt;
            {
                childAnswer
                .Should().Contain(ParentExpression)
                .And.Contain(ChildExpression);
            });

            "it should evaluate expressions from parent first"._(() =&gt;
            {
                childAnswer.EndsWith(ParentExpression + ChildExpression, StringComparison.Ordinal)
                .Should().BeTrue();
            });
    }

        [Scenario]
        public void When_calling_answer_on_a_parent_evaluation_engine()
        {
            string parentAnswer = null;

            "when calling answer on a child evaluation engine"._(() =&gt;
            {
                parentAnswer = ParentEngine.Answer(new Question());
            });

            "it should use parent aggregator"._(() =&gt;
            {
                parentAnswer.Should().Contain(ParentAggregator);
            });

            "it should use expressions only from parent"._(() =&gt;
            {
                parentAnswer.Should().NotContain(ChildExpression);
            });

        }
    }
}
</code></pre>

<p>And then some clean-up:</p>

<ul>
<li>remove partial</li>
<li>remove unnecessary <code>protected</code>
</li>
<li>better naming of establish in Background step</li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/ursenzler/MSpec2xBehaveConverter">Mspec2xbehaveconverter</a> is maintained by <a href="https://github.com/ursenzler">ursenzler</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

